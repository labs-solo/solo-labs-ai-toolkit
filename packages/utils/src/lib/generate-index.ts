#!/usr/bin/env node

import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import { execSync } from 'child_process';

interface ItemInfo {
  name: string;
  description: string;
  filePath: string;
}

export interface GenerateIndexOptions {
  srcPath: string;
  outputPath: string;
  typeName: string; // 'Agent' or 'CommandName'
  exportName: string; // 'agents' or 'commands'
  typeNamePlural?: string; // 'Agents' or 'Commands'
  regenerateCommand: string; // The nx command to regenerate
}

async function parseMarkdownFile(
  filePath: string,
  useFilenameAsName = false
): Promise<{ name: string; description: string } | null> {
  try {
    const content = await readFile(filePath, 'utf-8');

    // Look for YAML frontmatter
    const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!yamlMatch) {
      console.warn(`No YAML frontmatter found in ${filePath}`);
      return null;
    }

    const yamlContent = yamlMatch[1];

    // Extract description (always required)
    const descriptionMatch = yamlContent.match(/^description:\s*(.+)$/m);
    if (!descriptionMatch) {
      console.warn(`Missing description in ${filePath}`);
      return null;
    }

    let name: string;

    if (useFilenameAsName) {
      // For commands, use filename without extension as name
      const filename = filePath.split('/').pop()!;
      name = filename.replace('.md', '');
    } else {
      // For agents, extract name from YAML
      const nameMatch = yamlContent.match(/^name:\s*(.+)$/m);
      if (!nameMatch) {
        console.warn(`Missing name in ${filePath}`);
        return null;
      }
      name = nameMatch[1].trim();
    }

    const description = descriptionMatch[1].trim();

    // Remove quotes if present
    const cleanDescription = description.replace(/^["']|["']$/g, '');

    return { name, description: cleanDescription };
  } catch (error) {
    console.error(`Error parsing ${filePath}:`, error);
    return null;
  }
}

export async function generateIndex(
  options: GenerateIndexOptions
): Promise<void> {
  const { srcPath, outputPath, typeName, exportName, regenerateCommand } =
    options;

  // Read all files in src directory
  const files = await readdir(srcPath);

  // Filter for .md files (excluding any that might be documentation)
  const markdownFiles = files.filter((file) => file.endsWith('.md'));

  // Parse each file
  const items: ItemInfo[] = [];

  // Determine if we should use filename as name (for commands)
  const useFilenameAsName = typeName === 'CommandName';

  for (const file of markdownFiles) {
    const filePath = join(srcPath, file);
    const parsed = await parseMarkdownFile(filePath, useFilenameAsName);

    if (parsed) {
      items.push({
        name: parsed.name,
        description: parsed.description,
        filePath: `./${file}`,
      });
    }
  }

  // Sort items alphabetically by name
  items.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript content
  const typeUnion = items.map((item) => `  | '${item.name}'`).join('\n');

  const itemsObject = items
    .map((item) => {
      const key = item.name.includes('-') ? `'${item.name}'` : item.name;
      return `  ${key}: {
    description:
      '${item.description}',
    filePath: '${item.filePath}',
  }`;
    })
    .join(',\n');

  const indexContent =
    typeName === 'Agent'
      ? `// Auto-generated file - DO NOT EDIT
// Generated by @solo-labs/utils generate-index
// To regenerate, run: ${regenerateCommand}

// Agent types
type Agent =
${typeUnion};

type Agents = {
  [key in Agent]: {
    description: string;
    filePath: string;
  };
};

// Export agents with descriptions and file paths
export const agents: Agents = {
${itemsObject},
} as const;

export type AgentName = keyof typeof agents;`
      : `// Auto-generated file - DO NOT EDIT
// Generated by @solo-labs/utils generate-index
// To regenerate, run: ${regenerateCommand}

type CommandName =
${typeUnion};

export type Commands = {
  [key in CommandName]: {
    description: string;
    filePath: string;
  };
};

export const commands: Commands = {
${itemsObject},
} as const;`;

  // Write the generated index.ts
  await writeFile(outputPath, indexContent, 'utf-8');

  // Format the generated file using Prettier
  try {
    execSync(`npx prettier --write "${outputPath}"`, {
      stdio: 'pipe',
    });
  } catch (error) {
    console.warn('Warning: Failed to format generated file:', error);
  }

  console.log(`Generated index.ts with ${items.length} ${exportName}`);
  items.forEach((item) => {
    console.log(`  - ${item.name}`);
  });
}

// CLI support
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);

  if (args.length < 4) {
    console.error(
      'Usage: generate-index <srcPath> <outputPath> <type> <exportName> [regenerateCommand]'
    );
    console.error('  type: "Agent" or "CommandName"');
    console.error('  exportName: "agents" or "commands"');
    process.exit(1);
  }

  const [
    srcPath,
    outputPath,
    typeName,
    exportName,
    regenerateCommand = 'npx nx run <project>:generate-index',
  ] = args;

  generateIndex({
    srcPath,
    outputPath,
    typeName,
    exportName,
    regenerateCommand,
    typeNamePlural: `${typeName}s`,
  }).catch((error) => {
    console.error('Failed to generate index:', error);
    process.exit(1);
  });
}
